#!/usr/bin/python3
import os
import sys
import json
import base64
import argparse

from shutil import get_terminal_size
from openai import OpenAI

from prompt_toolkit import prompt
from prompt_toolkit.key_binding import KeyBindings

DEFAULT_SYSTEM_PROMPT = f"""
You are ChatGPT, a large language model trained by OpenAI.
Carefully heed the user's instructions.
Respond using Markdown.
You will respond briefly and concisely unless you are explicitly asked to do otherwise.
You will not include any extraneous or tangential details unless you are explicitly asked to do otherwise.
""".strip()

def get_file(file_path):
  path = os.path.relpath(os.path.abspath(file_path), os.getcwd())

  with open(path, 'r') as file:
    content = file.read()

  return path, content

class ChatGptCli:
  def __init__(
    self,
    log_file=None,
    log_file_json=None,
    interactive=True,
    immediate=False,
    model='gpt-4o',
    separator = None,
    intro=True,
    no_system_prompt=False,
    api_key=None,
    temperature=None,
    max_tokens=None,
    top_p=None,
    frequency_penalty=None,
    presence_penalty=None
  ):
    self.log_file = log_file
    self.json_log_file = log_file_json
    self.interactive = interactive
    self.immediate = immediate
    self.model = model
    self.separator = separator
    self.intro = intro
    self.no_system_prompt = no_system_prompt
    self.client = OpenAI(api_key=api_key)
    self.temperature = temperature
    self.max_tokens = max_tokens
    self.top_p = top_p
    self.frequency_penalty = frequency_penalty
    self.presence_penalty = presence_penalty
    self.messages = []

  def log_json(self):
      """Dump the messages to a JSON file."""
      if self.json_log_file:
        with open(self.json_log_file, 'w') as file:
            json.dump(self.messages, file, indent=4)

  def output(self, message, silent=False):
    if not silent:
      print(message, end='', flush=True)

    if self.log_file is not None:
      with open(self.log_file, 'a') as file:
        file.write(message)

  def get_completion(self):
    messages = []

    for message in self.messages:
      if message.get('role') == 'file':
        messages.append({
          "role": "user",
          "content": message.get('file_content')
        })
      elif message.get('role') == 'image':
        messages.append({
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "The user has included this image in their request."
            },
            {
              "type": "image_url",
              "image_url": {
                "url": message.get('image_content')
              }
            }
          ]
        })
      else:
        messages.append(message)

    response = self.client.chat.completions.create(
      messages=messages,
      model=self.model,
      temperature=self.temperature,
      max_tokens=self.max_tokens,
      top_p=self.top_p,
      frequency_penalty=self.frequency_penalty,
      presence_penalty=self.presence_penalty
    )
    return response.choices[0].message.content

  def get_separator(self):
    if self.separator is not None:
      return self.separator
    
    return '\n\n #' + ('=' * (get_terminal_size().columns - 4)) + '#\n\n'

  def add_chat_message(self, role, content, message=None, silent=False):
    if role == 'file':
      if message and 'file_content' in message:
        content = message.get('content')
        file_content = message.get('file_content')
      else:
        file_path = os.path.relpath(os.path.abspath(content), os.getcwd())
        content = f'FILE: {file_path} (contents hidden)'
        with open(file_path, 'r') as file:
          file_content = '### FILE: `{file_path}`\n```\n' + file.read() + '\n```'

      message = {
        "role": "file",
        "content": content,
        "file_content": file_content
      }
      self.messages.append(message)
      self.output(message.get('content'), silent=silent)
    elif role == 'image':
      # max_tokens is required for images
      if not self.max_tokens:
        self.max_tokens = 300

      if message and 'image_content' in message:
        content = message.get('content')
        image_content = message.get('image_content')
      else:
        file_path = os.path.relpath(os.path.abspath(content), os.getcwd())
        content = f'IMAGE: {file_path} (contents hidden)'
        with open(file_path, 'rb') as file:
          image_content = 'data:image/jpeg;base64,' + base64.b64encode(file.read()).decode('utf-8')
      message = {
        "role": "image",
        "content": content,
        "image_content": image_content
      }
      self.messages.append(message)
      self.output(message.get('content'), silent=silent)
    else:
      self.messages.append({"role": role, "content": content})
      self.output(f'{role.capitalize()}:\n\n{content}', silent=silent)
    
    self.output(self.get_separator(), silent=silent)

  def add_messages_from_args(self, args):
    silent = not self.interactive or not self.intro

    args_iter = iter(args)
    args_messages = []

    for arg in args_iter:
      if arg not in ('-s', '--system', '-a', '--assistant', '-u', '--user', '-f', '--file', '-i', '--image', '-c', '--conversation'):
        continue

      content = next(args_iter, None)

      if arg in ('-s', '--system'):
        args_messages.append({"role": "system", "content": content})
      elif arg in ('-a', '--assistant'):
        args_messages.append({"role": "assistant", "content": content})
      elif arg in ('-u', '--user'):
        args_messages.append({"role": "user", "content": content})
      elif arg in ('-f', '--file'):
        args_messages.append({"role": "file", "content": content})
      elif arg in ('-i', '--image'):
        args_messages.append({"role": "image", "content": content})
      elif arg in ('-c', '--conversation'):
        # so you can combine -c and -j on a file that doesn't exist yet
        if not os.path.exists(content) and self.json_log_file == content:
          continue

        with open(content, 'r') as file:
          conversation = json.load(file)
          for message in conversation:
            args_messages.append(message)

    if not self.no_system_prompt and not any(message.get("role") == "system" for message in args_messages):
      args_messages.insert(0, {"role": "system", "content": DEFAULT_SYSTEM_PROMPT})

    for message in args_messages:
      self.add_chat_message(message.get('role'), message.get('content'), message=message, silent=silent)

  def main(self, args):
    self.add_messages_from_args(args)

    if not self.interactive:
      response = self.get_completion()
      self.add_chat_message("assistant", response, silent=True)
      self.log_json()
      self.output(response)
      return
    
    if self.immediate:
      response = self.get_completion()
      self.add_chat_message("assistant", response)

    self.log_json()

    bindings = KeyBindings()
    bindings.add('c-c')(lambda _: sys.exit(0))
    bindings.add('c-d')(lambda _: sys.exit(0))
    bindings.add('enter')(lambda event: event.app.current_buffer.insert_text('\n'))

    while True:
      user_input = prompt(
        "User: (Multi-line editor, press Alt+Enter to submit. Press Ctrl+C or Ctrl+D to exit.)\n\n",
        multiline=True,
        key_bindings=bindings
      )
      self.add_chat_message("user", user_input, silent=True)
      self.log_json()

      self.output(self.get_separator())

      response = self.get_completion()
      self.add_chat_message("assistant", response)
      self.log_json()

def print_help():
  exec_path = os.path.basename(sys.argv[0])
  print(f"""
ChatGPT CLI

This command line interface allows you to interact with the ChatGPT model in various ways, including sending system prompts, assistant responses, user prompts, and loading previous conversations. It supports both interactive and non-interactive modes.

Usage:
  {exec_path} [options]

Options:
  MESSAGE ARGUMENTS:
  -s, --system <message>       Add a system prompt message. If not specified, a default system prompt is used.
  -a, --assistant <message>    Add an assistant response message.
  -u, --user <message>         Add a user prompt message.
  -f, --file <filename>        Add a user prompt message from a file.
  -i, --image <filename>       Add an image message from a file. If --max-tokens is not specified, a default value of 300 will be applied.
  -c, --conversation <file>    Load a previous conversation from a file. (see -j / --log-file-json)
  -d, --no-system-prompt       Don't add a default system prompt if none is present.
  
  MODEL ARGUMENTS:
  -m, --model <model_name>     Specify the model to use. (default: gpt-4o)
  --temperature <value>        The sampling temperature to use, between 0 and 1.
  --max-tokens <number>        The maximum number of tokens to generate in the completion.
  --top-p <value>              The top-p sampling value to use, between 0 and 1.
  --frequency-penalty <value>  The frequency penalty to use, between -2.0 and 2.0.
  --presence-penalty <value>   The presence penalty to use, between -2.0 and 2.0.
        
  OTHER ARGUMENTS:
  -n, --non-interactive        Disable interactive mode, get a completion and exit. Use message arguments to specify the conversation.
  -l, --log-file <filename>    Log output to a specified file.
  -j, --log-file-json <file>   Output a JSON-formatted log to a specified file.
  -g, --immediate              Get an assistant response immediately, before entering interactive mode.
  -x, --separator <separator>  Specify the separator to use between messages.
  -o, --no-intro               Don't print the system prompt, or messages specified on the command line.
  -h, --help                   Print this help message and exit.

Message arguments are added to the conversation in the order in which they are specified on the command line. If no system prompt is specified, a default prompt will be added.

By default, the program begins in interactive mode. Interactive mode uses a multi-line editor, press Alt+Enter to submit, and Ctrl+C or Ctrl+D to exit.

Make sure you set the OPENAI_API_KEY environment variable to your OpenAI API key.

TIP: Try `{exec_path} -c mylog.json -j mylog.json` to persist conversations between sessions.
        """.strip())

def main():
  parser = argparse.ArgumentParser(
    description='ChatGPT CLI',
    add_help=False,
  )

  # Message arguments
  # Argparse is just validating these, we parse them manually below
  parser.add_argument('-s', '--system', action='append')
  parser.add_argument('-a', '--assistant', action='append')
  parser.add_argument('-u', '--user', action='append')
  parser.add_argument('-f', '--file', action='append')
  parser.add_argument('-i', '--image', action='append')
  parser.add_argument('-c', '--conversation', action='append')
  parser.add_argument('-d', '--no-system-prompt', action='store_true')

  # Model arguments
  parser.add_argument('--temperature', type=float)
  parser.add_argument('--max-tokens', type=int)
  parser.add_argument('--top-p', type=float)
  parser.add_argument('--frequency-penalty', type=float)
  parser.add_argument('--presence-penalty', type=float)

  # Other arguments
  parser.add_argument('-n', '--non-interactive', action='store_true')
  parser.add_argument('-l', '--log-file')
  parser.add_argument('-j', '--log-file-json')
  parser.add_argument('-m', '--model', default='gpt-4o')
  parser.add_argument('-g', '--immediate', action='store_true')
  parser.add_argument('-x', '--separator')
  parser.add_argument('-o', '--no-intro', action='store_true')
  parser.add_argument('-h', '--help', action='store_true')

  args = parser.parse_args()

  if args.help:
    print_help()
    return

  if (os.environ.get("OPENAI_API_KEY") is None):
    print("Please set the OPENAI_API_KEY environment variable to your OpenAI API key. Use -h for help.")
    sys.exit(1)

  cli = ChatGptCli(
    log_file=args.log_file,
    log_file_json=args.log_file_json,
    interactive=not args.non_interactive,
    model=args.model,
    immediate=args.immediate,
    separator=args.separator,
    intro=not args.no_intro,
    no_system_prompt=args.no_system_prompt,
    api_key=os.environ.get("OPENAI_API_KEY"),
    temperature=args.temperature,
    max_tokens=args.max_tokens,
    top_p=args.top_p,
    frequency_penalty=args.frequency_penalty,
    presence_penalty=args.presence_penalty
  )

  cli.main(sys.argv[1:])

if __name__ == "__main__":
  main()
