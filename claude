#!/usr/bin/python3
import os
import sys
import json
import base64
import argparse

from shutil import get_terminal_size
import anthropic

from prompt_toolkit import prompt
from prompt_toolkit.key_binding import KeyBindings

DEFAULT_SYSTEM_PROMPT = f"""
You are Claude, a large language model trained by Anthropic.
Carefully heed the user's instructions.
""".strip()

def get_file(file_path):
  path = os.path.relpath(os.path.abspath(file_path), os.getcwd())

  with open(path, 'r') as file:
    content = file.read()

  return path, content

class ClaudeCli:
  def __init__(
    self,
    log_file=None,
    log_file_json=None,
    interactive=True,
    immediate=False,
    model='gpt-4o',
    separator = None,
    intro=True,
    no_system_prompt=False,
    temperature=None,
    max_tokens=None,
    top_p=None
  ):
    self.log_file = log_file
    self.json_log_file = log_file_json
    self.interactive = interactive
    self.immediate = immediate
    self.model = model
    self.separator = separator
    self.intro = intro
    self.no_system_prompt = no_system_prompt
    self.client = anthropic.Anthropic()
    self.temperature = temperature
    self.max_tokens = max_tokens
    self.top_p = top_p
    self.system = DEFAULT_SYSTEM_PROMPT
    self.messages = []

  def log_json(self):
      """Dump the messages to a JSON file."""
      if self.json_log_file:
        with open(self.json_log_file, 'w') as file:
            json.dump(self.messages, file, indent=4)

  def output(self, message, silent=False):
    if not silent:
      print(message, end='', flush=True)

    if self.log_file is not None:
      with open(self.log_file, 'a') as file:
        file.write(message)

  def get_completion(self):
    messages = []

    for message in self.messages:
      if message.get('role') == 'file':
        messages.append({
          "role": "user",
          "content": message.get('file_content')
        })
      elif message.get('role') == 'image':
        messages.append({
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "The user has included this image in their request."
            },
            {
              "type": "image_url",
              "image_url": {
                "url": message.get('image_content')
              }
            }
          ]
        })
      else:
        messages.append(message)

    req = {}

    if self.temperature is not None:
        req['temperature'] = self.temperature
    if self.max_tokens is not None:
        req['max_tokens'] = self.max_tokens
    if self.top_p is not None:
        req['top_p'] = self.top_p
    if self.system is not None:
        req['system'] = self.system

    req['model'] = self.model
    req['messages'] = messages

    response = self.client.messages.create(**req)
    return response.content[0].text

  def get_separator(self):
    if self.separator is not None:
      return self.separator
    
    return '\n\n #' + ('=' * (get_terminal_size().columns - 4)) + '#\n\n'

  def add_chat_message(self, role, content, message=None, silent=False):
    if role == 'file':
      if message and 'file_content' in message:
        content = message.get('content')
        file_content = message.get('file_content')
      else:
        file_path = os.path.relpath(os.path.abspath(content), os.getcwd())
        content = f'FILE: {file_path} (contents hidden)'
        with open(file_path, 'r') as file:
          file_content = '### FILE: `{file_path}`\n```\n' + file.read() + '\n```'

      message = {
        "role": "file",
        "content": content,
        "file_content": file_content
      }
      self.messages.append(message)
      self.output(message.get('content'), silent=silent)
    elif role == 'image':
      # max_tokens is required for images
      if not self.max_tokens:
        self.max_tokens = 300

      if message and 'image_content' in message:
        content = message.get('content')
        image_content = message.get('image_content')
      else:
        file_path = os.path.relpath(os.path.abspath(content), os.getcwd())
        content = f'IMAGE: {file_path} (contents hidden)'
        with open(file_path, 'rb') as file:
          image_content = 'data:image/jpeg;base64,' + base64.b64encode(file.read()).decode('utf-8')
      message = {
        "role": "image",
        "content": content,
        "image_content": image_content
      }
      self.messages.append(message)
      self.output(message.get('content'), silent=silent)
    elif role == 'system':
      self.system = content
      self.output(f'{role.capitalize()}:\n\n{content}', silent=silent)
    else:
      self.messages.append({"role": role, "content": content})
      self.output(f'{role.capitalize()}:\n\n{content}', silent=silent)
    
    self.output(self.get_separator(), silent=silent)

  def add_messages_from_args(self, args):
    silent = not self.interactive or not self.intro

    args_iter = iter(args)
    args_messages = []

    for arg in args_iter:
      if arg not in ('-s', '--system', '-a', '--assistant', '-u', '--user', '-f', '--file', '-i', '--image', '-c', '--conversation'):
        continue

      content = next(args_iter, None)

      if arg in ('-s', '--system'):
        args_messages.append({"role": "system", "content": content})
      elif arg in ('-a', '--assistant'):
        args_messages.append({"role": "assistant", "content": content})
      elif arg in ('-u', '--user'):
        args_messages.append({"role": "user", "content": content})
      elif arg in ('-f', '--file'):
        args_messages.append({"role": "file", "content": content})
      elif arg in ('-i', '--image'):
        args_messages.append({"role": "image", "content": content})
      elif arg in ('-c', '--conversation'):
        # so you can combine -c and -j on a file that doesn't exist yet
        if not os.path.exists(content) and self.json_log_file == content:
          continue

        with open(content, 'r') as file:
          conversation = json.load(file)
          for message in conversation:
            args_messages.append(message)

    if not self.no_system_prompt and not any(message.get("role") == "system" for message in args_messages):
      args_messages.insert(0, {"role": "system", "content": DEFAULT_SYSTEM_PROMPT})

    for message in args_messages:
      self.add_chat_message(message.get('role'), message.get('content'), message=message, silent=silent)

  def main(self, args):
    self.add_messages_from_args(args)

    if not self.interactive:
      response = self.get_completion()
      self.add_chat_message("assistant", response, silent=True)
      self.log_json()
      self.output(response)
      return
    
    if self.immediate:
      response = self.get_completion()
      self.add_chat_message("assistant", response)

    self.log_json()

    bindings = KeyBindings()
    bindings.add('c-c')(lambda _: sys.exit(0))
    bindings.add('c-d')(lambda _: sys.exit(0))
    bindings.add('enter')(lambda event: event.app.current_buffer.insert_text('\n'))

    while True:
      user_input = prompt(
        "User: (Multi-line editor, press Alt+Enter to submit. Press Ctrl+C or Ctrl+D to exit.)\n\n",
        multiline=True,
        key_bindings=bindings
      )
      self.add_chat_message("user", user_input, silent=True)
      self.log_json()

      self.output(self.get_separator())

      response = self.get_completion()
      self.add_chat_message("assistant", response)
      self.log_json()

def print_help():
  exec_path = os.path.basename(sys.argv[0])
  print(f"""
Claude CLI

This command line interface allows you to interact with the Claude model in various ways, including sending system prompts, assistant responses, user prompts, and loading previous conversations. It supports both interactive and non-interactive modes.

Usage:
  {exec_path} [options]

Options:
  MESSAGE ARGUMENTS:
  -s, --system <message>       Add a system prompt message. If not specified, a default system prompt is used.
  -a, --assistant <message>    Add an assistant response message.
  -u, --user <message>         Add a user prompt message.
  -f, --file <filename>        Add a user prompt message from a file.
  -i, --image <filename>       Add an image message from a file.
  -c, --conversation <file>    Load a previous conversation from a file. (see -j / --log-file-json)
  -d, --no-system-prompt       Don't add a default system prompt if none is present.
  
  MODEL ARGUMENTS:
  -m, --model <model_name>     Specify the model to use. (default: claude-3-5-sonnet-20240620)
  --temperature <value>        The sampling temperature to use, between 0 and 1. (default: 0)
  --max-tokens <number>        The maximum number of tokens to generate in the completion. (default: 1000)
  --top-p <value>              The top-p sampling value to use, between 0 and 1.
        
  OTHER ARGUMENTS:
  -n, --non-interactive        Disable interactive mode, get a completion and exit. Use message arguments to specify the conversation.
  -l, --log-file <filename>    Log output to a specified file.
  -j, --log-file-json <file>   Output a JSON-formatted log to a specified file.
  -g, --immediate              Get an assistant response immediately, before entering interactive mode.
  -x, --separator <separator>  Specify the separator to use between messages.
  -o, --no-intro               Don't print the system prompt, or messages specified on the command line.
  -h, --help                   Print this help message and exit.

Message arguments are added to the conversation in the order in which they are specified on the command line. If no system prompt is specified, a default prompt will be added.

By default, the program begins in interactive mode. Interactive mode uses a multi-line editor, press Alt+Enter to submit, and Ctrl+C or Ctrl+D to exit.

Make sure you set the ANTHROPIC_API_KEY environment variable to your Anthropic API key.

TIP: Try `{exec_path} -c mylog.json -j mylog.json` to persist conversations between sessions.
        """.strip())

def main():
  parser = argparse.ArgumentParser(
    description='Claude CLI',
    add_help=False,
  )

  # Message arguments
  # Argparse is just validating these, we parse them manually below
  parser.add_argument('-s', '--system', action='append')
  parser.add_argument('-a', '--assistant', action='append')
  parser.add_argument('-u', '--user', action='append')
  parser.add_argument('-f', '--file', action='append')
  parser.add_argument('-i', '--image', action='append')
  parser.add_argument('-c', '--conversation', action='append')
  parser.add_argument('-d', '--no-system-prompt', action='store_true')

  # Model arguments
  parser.add_argument('--temperature', type=float, default=0)
  parser.add_argument('--max-tokens', type=int, default=1000)
  parser.add_argument('--top-p', type=float)

  # Other arguments
  parser.add_argument('-n', '--non-interactive', action='store_true')
  parser.add_argument('-l', '--log-file')
  parser.add_argument('-j', '--log-file-json')
  parser.add_argument('-m', '--model', default='claude-3-5-sonnet-20240620')
  parser.add_argument('-g', '--immediate', action='store_true')
  parser.add_argument('-x', '--separator')
  parser.add_argument('-o', '--no-intro', action='store_true')
  parser.add_argument('-h', '--help', action='store_true')

  args = parser.parse_args()

  if args.help:
    print_help()
    return

  if (os.environ.get("ANTHROPIC_API_KEY") is None):
    print("Please set the ANTHROPIC_API_KEY environment variable to your Anthropic API key. Use -h for help.")
    sys.exit(1)

  cli = ClaudeCli(
    log_file=args.log_file,
    log_file_json=args.log_file_json,
    interactive=not args.non_interactive,
    model=args.model,
    immediate=args.immediate,
    separator=args.separator,
    intro=not args.no_intro,
    no_system_prompt=args.no_system_prompt,
    temperature=args.temperature,
    max_tokens=args.max_tokens,
    top_p=args.top_p
  )

  cli.main(sys.argv[1:])

if __name__ == "__main__":
  main()
